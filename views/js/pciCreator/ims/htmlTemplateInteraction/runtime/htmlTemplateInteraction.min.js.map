{"version":3,"names":["define","events","get","event","on","callback","name","tokens","split","shift","push","ns","off","trigger","data","forEach","e","apply","type","EventMgr","addEventMgr","instance","eventMgr","createRecord","entries","arguments","length","names","map","entry","Set","size","Error","record","createRecordEntry","baseType","value","base","getRecordEntryValue","match","find","Object","values","qtiCustomInteractionContext","markupInnerHtml","createBlobURL","code","blobUrl","URL","createObjectURL","Blob","blobUrls","add","revokeBlobUrls","url","revokeObjectURL","getCounts","text","wordMatches","words","chars","getElementInfo","element","typeAttr","getAttribute","isTextArea","tagName","isSelect","isSelectMultiple","isTextInput","includes","isCheckboxInput","isRadioInput","isUnsupportedElement","htmlTemplateInteractionFactory","typeIdentifier","_typeIdentifier","getResponse","recordEntries","usedGroupNames","getResponseElts","substring","maxlength","checked","radioGroupCheckedElt","iframe","contentDocument","querySelector","responseRecordValue","destroy","dom","innerHTML","getTypeIdentifier","initialize","responseIdentifier","properties","wrapper","document","createElement","append","outerHTML","dataset","dispatchEvent","CustomEvent","bubbles","detail","render","iframeOnload","postRender","removeEventListener","addEventListener","src","html","console","error","height","contentWindow","body","scrollHeight","warn","setAttribute","isReviewMode","renderResponseValues","connectWordcounts","elts","querySelectorAll","filter","elt","elementResponseValue","options","optionElt","selected","wordcountTargets","wcTarget","wcSource","wordcountFor","textContent","target","setResponse","response","resetResponse","setSerializedState","state","getSerializedState","log","register","getInstance","config","interaction","pciInstance","getState","oncompleted","keys","boundTo","newProperties","assign","onready","IMSPCI"],"sources":["../build/config-wrap-start-default.js","../../../taoQtiItem/views/js/portableLib/OAT/util/EventMgr.js","../../../taoQtiItem/views/js/portableLib/OAT/util/event.js","../../../qtiItemPci/views/js/pciCreator/ims/htmlTemplateInteraction/runtime/recordResponse.js","../../../qtiItemPci/views/js/pciCreator/ims/htmlTemplateInteraction/runtime/tpl/markupInner.tpl!text","../../../qtiItemPci/views/js/pciCreator/ims/htmlTemplateInteraction/runtime/htmlTemplateInteraction.js","../build/config-wrap-end-default.js"],"sourcesContent":["\n","/*\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; under version 2\n * of the License (non-upgradable).\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * Copyright (c) 2017-2024 (original work) Open Assessment Technologies SA;\n *\n */\ndefine('taoQtiItem/portableLib/OAT/util/EventMgr',[],function() {\n    'use strict';\n\n    return function EventMgr() {\n        const events = {};\n\n        this.get = event => {\n            if (event && events[event]) {\n                return [...events[event]];\n            } else {\n                return [];\n            }\n        };\n\n        this.on = (event, callback) => {\n            let name;\n            const tokens = event.split('.');\n            if (tokens[0]) {\n                name = tokens.shift();\n                events[name] = events[name] || [];\n                events[name].push({\n                    ns: tokens,\n                    callback: callback\n                });\n            }\n        };\n\n        this.off = event => {\n            if (event && events[event]) {\n                events[event] = [];\n            }\n        };\n\n        this.trigger = (event, data) => {\n            if (events[event]) {\n                events[event].forEach(e => {\n                    e.callback.apply({\n                        type: event,\n                        ns: []\n                    }, data);\n                });\n            }\n        };\n    };\n});\n\n","/*\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; under version 2\n * of the License (non-upgradable).\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * Copyright (c) 2017-2024 (original work) Open Assessment Technologies SA;\n *\n */\ndefine('taoQtiItem/portableLib/OAT/util/event',['taoQtiItem/portableLib/OAT/util/EventMgr'], function(EventMgr) {\n    return {\n        addEventMgr: function(instance) {\n            const eventMgr = new EventMgr();\n\n            instance.on = (event, callback) => {\n                eventMgr.on(event, callback);\n            };\n            instance.off = event => {\n                eventMgr.off(event);\n            };\n            instance.trigger = (event, data) => {\n                eventMgr.trigger(event, data);\n            };\n        }\n    };\n});\n\n","/**\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; under version 2\n * of the License (non-upgradable).\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * Copyright (c) 2024 (original work) Open Assessment Technologies SA ;\n */\n/**\n * Helper module for \"cardinality\": \"record\" response type (with limited support)\n * @example of supported fields\n{\n  \"record\": [\n    {\n      \"name\": \"textarea1\",\n      \"base\": {\n        \"string\": \"this is my response\"\n      }\n    },\n    {\n      \"name\": \"select1\",\n      \"base\": {\n        \"identifier\": \"option_name1\"\n      }\n    },\n    {\n      \"name\": \"checkbox1\",\n      \"base\": {\n        \"boolean\": true\n      }\n    },\n    {\n      \"name\": \"radio1\",\n      \"base\": {\n        \"identifier\": \"radio_value1\"\n      }\n    }\n  ]\n}\n */\ndefine('htmlTemplateInteraction/runtime/recordResponse',[],function() {\n    'use strict';\n\n    /**\n     * @typedef {object} RecordEntry\n     * @property {string} name\n     * @property {object} base - list is not supported\n     * @property {string} [base.string]\n     * @property {string} [base.identifier]\n     * @property {Boolean} [base.boolean]\n     */\n\n    /**\n     * Check and structure record entries into the format needed within a QTI response\n     * @param {RecordEntry[]} entries\n     * @returns {object}\n     */\n    function createRecord(entries = []) {\n        const names = entries.map(entry => entry.name);\n        if (names.length > new Set(names).size) {\n            throw new Error('Cannot createRecord with duplicate names');\n        }\n        return {\n            record: [...entries]\n        };\n    }\n\n    /**\n     * Format a named and typed value as a record entry\n     * @param {string} name\n     * @param {string} baseType - string, identifier, boolean supported\n     * @param {*} value\n     * @returns {RecordEntry}\n     */\n    function createRecordEntry(name, baseType, value = null) {\n        if (!name) {\n            throw new Error(`Cannot createRecordEntry with name: ${name}`);\n        }\n        if (value === null) {\n            return {\n                name,\n                base: null\n            };\n        }\n        return {\n            name,\n            base: {\n                [baseType]: value\n            }\n        };\n    }\n\n    /**\n     * Extract a named value from record entries\n     * @param {RecordEntry[]} entries\n     * @param {string} name\n     * @returns {*} value\n     */\n    function getRecordEntryValue(entries = [], name = '') {\n        const match = entries.find(entry => entry.name === name);\n        if (!match) {\n            return null;\n        }\n        return match.base && Object.values(match.base)[0];\n    }\n\n    return {\n        createRecord,\n        createRecordEntry,\n        getRecordEntryValue\n    };\n});\n\n","\ndefine('text!htmlTemplateInteraction/runtime/tpl/markupInner.tpl',[],function () { return '<div class=\"iframe-wrapper\" style=\"position:relative\">\\n    <iframe title=\"interaction\" sandbox=\"allow-same-origin\" style=\"width:100%;border:none;\"></iframe>\\n</div>';});\n\n","/*\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; under version 2\n * of the License (non-upgradable).\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * Copyright (c) 2024 (original work) Open Assessment Technologies SA;\n *\n */\ndefine('htmlTemplateInteraction/runtime/htmlTemplateInteraction',[\n    'qtiCustomInteractionContext',\n    'taoQtiItem/portableLib/OAT/util/event',\n    'htmlTemplateInteraction/runtime/recordResponse',\n    'text!htmlTemplateInteraction/runtime/tpl/markupInner.tpl',\n], function (qtiCustomInteractionContext, event, record, markupInnerHtml) {\n    'use strict';\n\n    console.log('in src runtime');\n\n    const _typeIdentifier = 'htmlTemplateInteraction';\n\n    const maxlength = 10000; // limit individual input value lengths\n\n    let blobUrls = new Set();\n\n    /**\n     * Prepare iframe src from html template\n     * @param {string} code\n     * @param {string} [type]\n     * @returns {string} blob URL - should be revoked when finished with\n     */\n    function createBlobURL(code, type = 'text/html') {\n        const blobUrl = URL.createObjectURL(new Blob([code], { type }));\n        blobUrls.add(blobUrl);\n        return blobUrl;\n    };\n\n    /**\n     * Revoke all stored blob URLs. Prevents memory leak when repeatedly editing html property in creator.\n     */\n    function revokeBlobUrls() {\n        for (const url of blobUrls.values()) {\n            URL.revokeObjectURL(url);\n        }\n        blobUrls = new Set();\n    }\n\n    /**\n     * Count words/chars in string according to built-in word separators\n     * @param {string} text\n     * @returns {Object} counts\n     */\n    function getCounts(text = '') {\n        const wordSeparators = '\\\\s.,:;?!&#%/*+=';\n        const wordRegex = new RegExp(`[^${wordSeparators}]+`, 'g');\n        const wordMatches = (typeof text === 'string' && text.match(wordRegex)) || [];\n        return {\n            words: wordMatches.length,\n            chars: text.length\n        };\n    }\n\n    /**\n     * Find out what type of HTMLElement a response element is.\n     * Supported types:\n     * - textarea\n     * - select (not multiple)\n     * - input type=\"text|number|email|url|search\"\n     * - input type=\"checkbox\"\n     * - input type=\"radio\"\n     * @param {HTMLElement} element\n     * @returns {Object}\n     */\n    function getElementInfo(element) {\n        if (!element) {\n            return {};\n        }\n        const typeAttr = element.getAttribute('type');\n        const isTextArea = element.tagName === 'TEXTAREA';\n        const isSelect = element.tagName === 'SELECT';\n        const isSelectMultiple = isSelect && element.getAttribute('multiple');\n        const isTextInput = element.tagName === 'INPUT' && (['text', 'number', 'email', 'url', 'search'].includes(typeAttr) || !typeAttr);\n        const isCheckboxInput = element.tagName === 'INPUT' && typeAttr === 'checkbox';\n        const isRadioInput = element.tagName === 'INPUT' && typeAttr === 'radio';\n        const isUnsupportedElement = !isTextArea && !(isSelect && !isSelectMultiple) && !isTextInput && !isCheckboxInput && !isRadioInput;\n\n        return { isTextArea, isSelect, isTextInput, isCheckboxInput, isRadioInput, isUnsupportedElement };\n    }\n\n    function htmlTemplateInteractionFactory() {\n        return {\n\n            /*********************************\n             *\n             * IMS specific PCI API property and methods\n             *\n             *********************************/\n\n            typeIdentifier: _typeIdentifier,\n\n            /*********************************\n             *\n             * TAO and IMS shared PCI API methods\n             *\n             *********************************/\n\n            /**\n             * Get the response in the json format described in\n             * http://www.imsglobal.org/assessment/pciv1p0cf/imsPCIv1p0cf.html#_Toc353965343\n             * HTML response elements give up the following data:\n             * - textarea: { name: name, base: { string: value } }\n             * - select: { name: name, base: { identifier: option_value } }\n             * - input type=\"text|number|email|url|search\": { name: name, base: { string: value } }\n             * - input type=\"checkbox\": { name: name, base: { boolean: checked } }\n             * - input type=\"radio\": { name: name, base: { identifier: value } }\n             *\n             * @returns {Object}\n             */\n            getResponse: function() {\n                const recordEntries = [];\n                const usedGroupNames = [];\n\n                this.getResponseElts().forEach(element => {\n                    const { isTextArea, isSelect, isTextInput, isCheckboxInput, isRadioInput } = getElementInfo(element);\n\n                    if (isTextArea || isTextInput) {\n                        recordEntries.push(record.createRecordEntry(element.name, 'string', element.value && element.value.substring(0, maxlength) || null));\n                    } else if (isSelect) {\n                        recordEntries.push(record.createRecordEntry(element.name, 'identifier', element.value || null));\n                    } else if (isCheckboxInput) {\n                        recordEntries.push(record.createRecordEntry(element.name, 'boolean', element.checked));\n                    } else if (isRadioInput) {\n                        if (!usedGroupNames.includes(element.name)) {\n                            // only 1 radio input from a group should become its RecordEntry\n                            const radioGroupCheckedElt = this.iframe.contentDocument.querySelector(`input[type=radio][name=${element.name}][data-response]:checked`);\n                            const value = radioGroupCheckedElt ? radioGroupCheckedElt.value : null\n                            recordEntries.push(record.createRecordEntry(element.name, 'identifier', value));\n                            usedGroupNames.push(element.name);\n                        }\n                    }\n                });\n\n                // in case DOM was already destroyed, we can return last known response\n                if (recordEntries.length) {\n                    this.responseRecordValue = recordEntries;\n                }\n                return record.createRecord(this.responseRecordValue);\n            },\n\n            /**\n             * Reverse operation performed by render()\n             * After this function is executed, only the inital naked markup remains\n             */\n            destroy: function() {\n                this.dom.innerHTML = '';\n                revokeBlobUrls();\n            },\n\n\n            /*********************************\n             *\n             * TAO specific PCI API methods\n             *\n             *********************************/\n\n            /**\n             * Get the type identifier of a pci\n              * @returns {string}\n             */\n            getTypeIdentifier: function() {\n                return _typeIdentifier;\n            },\n\n            /**\n             * Render the PCI markup (only once)\n             * @param {String} responseIdentifier\n             * @param {HTMLElement} dom - container provided by host\n             * @param {Object} properties (PCI's config.properties)\n             */\n            initialize: function(responseIdentifier, dom, properties) {\n                this.responseIdentifier = responseIdentifier;\n                this.dom = dom;\n                this.properties = properties || {};\n\n                // create inner markup elements (so markup in item XML is kept to a minimum)\n                const wrapper = document.createElement('div');\n                dom.querySelector('.htmlTemplateInteraction').append(wrapper);\n                wrapper.outerHTML = markupInnerHtml;\n\n                this.iframe = dom.querySelector('iframe');\n                this.iframe.dataset.responseIdentifier = responseIdentifier;\n\n                dom.dispatchEvent(new CustomEvent('init', { bubbles: true, detail: { iframe: this.iframe } }));\n                this.render();\n            },\n\n            /**\n             * Render the contents of the iframe\n             */\n            render: function() {\n                const iframeOnload = () => this.postRender();\n\n                this.iframe.removeEventListener('load', iframeOnload);\n                this.iframe.addEventListener('load', iframeOnload);\n\n                // fill the markup-iframe\n                revokeBlobUrls();\n                try {\n                    this.iframe.src = createBlobURL(this.properties.html);\n                } catch (e) {\n                    console.error(e);\n                    this.iframe.src = createBlobURL('Invalid or missing <code>html</code> property');\n                }\n            },\n\n            /**\n             * Wire up events and attributes after the iframe is done loading\n             */\n            postRender: function() {\n                this.iframe.height = this.iframe.contentWindow.document.body.scrollHeight || 500;\n\n                // Update some attributes (not response values) on rendered response elements\n                this.getResponseElts().forEach(element => {\n                    const { isTextArea, isSelect, isTextInput, isCheckboxInput, isRadioInput, isUnsupportedElement } = getElementInfo(element);\n\n                    if (isUnsupportedElement) {\n                        console.warn('Unsupported data-response element in template:', element.outerHTML);\n                    } else if (!element.name) {\n                        console.warn('Response element found without name attribute and won\\'t be considered:', element.outerHTML);\n                    } else if (isTextArea || isTextInput) {\n                        element.setAttribute('maxlength', element.getAttribute('maxlength') || maxlength);\n                        if (this.properties.isReviewMode) {\n                            element.setAttribute('readonly', 'true');\n                        }\n                    } else if (isSelect || isCheckboxInput || isRadioInput) {\n                        if (this.properties.isReviewMode) {\n                            element.setAttribute('disabled', 'true');\n                        }\n                    }\n                });\n\n                this.renderResponseValues();\n                this.connectWordcounts();\n            },\n\n            /**\n             * Get the rendered element(s) defined by the template as holding the response(s)\n             * and defined by the PCI as supported.\n             * @returns {HTMLElement[]}\n             */\n            getResponseElts: function() {\n                if (!this.iframe.contentDocument) {\n                    return [];\n                }\n                const elts = [...this.iframe.contentDocument.querySelectorAll('[data-response][name]')];\n                return elts.filter(elt => !getElementInfo(elt).isUnsupportedElement);\n            },\n\n            /**\n             * Renders known response values into their DOM elements\n             */\n            renderResponseValues: function() {\n                if (!this.responseRecordValue) {\n                    return;\n                }\n                this.getResponseElts().forEach(element => {\n                    const { isTextArea, isTextInput, isSelect, isCheckboxInput, isRadioInput } = getElementInfo(element);\n\n                    const elementResponseValue = record.getRecordEntryValue(this.responseRecordValue, element.name);\n\n                    if (isTextArea || isTextInput) {\n                        element.value = elementResponseValue || '';\n                    } else if (isSelect) {\n                        const options = element.querySelectorAll('option');\n                        options.forEach(optionElt => {\n                            optionElt.selected = optionElt.value === elementResponseValue;\n                        });\n                    } else if (isCheckboxInput) {\n                        element.checked = !!elementResponseValue;\n                    } else if (isRadioInput) {\n                        element.checked = elementResponseValue === element.getAttribute('value');\n                    }\n                });\n            },\n\n            /**\n             * Update the content of data-wordcount-for elements with their word count texts\n             */\n            connectWordcounts: function() {\n                const wordcountTargets = this.iframe.contentDocument.querySelectorAll('[data-wordcount-for]') || [];\n                wordcountTargets.forEach(wcTarget => {\n                    const wcSource = this.iframe.contentDocument.querySelector(`[name=${wcTarget.dataset.wordcountFor}]`);\n                    const { isTextArea, isTextInput } = getElementInfo(wcSource);\n                    if (isTextArea || isTextInput) {\n                        // initial\n                        const { words } = getCounts(wcSource.value);\n                        wcTarget.textContent = `${words} word(s)`;\n\n                        // updates\n                        wcSource.addEventListener('input', (e) => {\n                            const { words } = getCounts(e.target.value);\n                            wcTarget.textContent = `${words} word(s)`;\n                        });\n                    }\n                });\n            },\n\n            /**\n             * Programmatically set the response following the json schema described in\n             * http://www.imsglobal.org/assessment/pciv1p0cf/imsPCIv1p0cf.html#_Toc353965343\n             *\n             * @param {Object} response\n             */\n            setResponse: function(response) {\n                if (response && response.record) {\n                    this.responseRecordValue = response.record || [];\n                    this.renderResponseValues();\n                }\n            },\n\n            /**\n             * Remove the current response set in the interaction\n             * The state may not be restored at this point.\n             */\n            resetResponse: function() {\n                this.setResponse({ record: [] });\n            },\n\n            /**\n             * Restore the state of the interaction from the serializedState.\n             *\n             * @param {Object} serializedState - json format\n             */\n            setSerializedState: function(state) {\n                if (state && state.response) {\n                    this.setResponse(state.response);\n                }\n            },\n\n            /**\n             * Get the current state of the interaction as a string.\n             * It enables saving the state for later usage.\n             *\n             * @returns {Object} json format\n             */\n            getSerializedState: function() {\n                return { response: this.getResponse() };\n            }\n        }\n    };\n\n    qtiCustomInteractionContext.register({\n        typeIdentifier: _typeIdentifier,\n\n        /**\n         * initialize the PCI object. As this object is cloned for each instance, using \"this\" is safe practice.\n         * @param {HTMLElement} dom - the interaction DOM container\n         * @param {Object} config\n         * @param {Object} config.properties - PCI properties\n         * @param {Object} config.boundTo - the response bound to the interaction\n         * @param {Function} config.onready - to be called when the PCI is ready to be used by test taker\n         * @param {Object} state - the state to restore\n         */\n        getInstance(dom, config, state) {\n            const interaction = htmlTemplateInteractionFactory();\n\n            // create a IMS PCI instance object that will be provided in onready\n            const pciInstance = {\n                /**\n                 * Get the current response of the PCI\n                 * @returns {Object}\n                 */\n                getResponse() {\n                    return interaction.getResponse();\n                },\n\n                /**\n                 * Get the current state of the PCI\n                 * @returns {Object}\n                 */\n                getState() {\n                    return interaction.getSerializedState();\n                },\n\n                /**\n                 * Called by delivery engine when PCI is fully completed\n                 */\n                oncompleted() {\n                    interaction.destroy();\n                }\n            };\n\n            const defaultResponse = { record: [] };\n            const responseIdentifier = Object.keys(config.boundTo)[0];\n            const response = config.boundTo[responseIdentifier] || defaultResponse;\n\n            interaction.initialize(responseIdentifier, dom, config.properties);\n            interaction.setResponse(response); // ?\n            interaction.setSerializedState(state); // ?\n\n            // event manager is necessary only for creator part\n            event.addEventMgr(pciInstance); // adds methods 'on', 'off', 'trigger'\n\n            // when in creator, respond to property changes\n            pciInstance.on('configChange', newProperties => {\n                Object.assign(interaction.properties, newProperties);\n                interaction.render();\n            });\n\n            // callback when the PCI is ready to be used\n            if (typeof config.onready === 'function') {\n                config.onready(pciInstance, state);\n            }\n\n            interaction.pciInstance = pciInstance;\n        }\n    });\n});\n\n","define(['htmlTemplateInteraction/runtime/htmlTemplateInteraction'],function(IMSPCI){return IMSPCI});\n"],"mappings":"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"}